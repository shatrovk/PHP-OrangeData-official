# PHPOrangeData
PHP integration for OrangeData service

Актуальная версия библиотеки: 2.1.1

Для начала работы необходимо подключить файл класса, например так:

```
include_once 'orangedata_client.php'; //Путь к библиотеке
```

Следует указать исходные данные:

Порт, на который будем отправлять запросы:
```
$api_url = 2443;
```

или адрес API или прокси:
```
$api_url = 'https://apip.orangedata.ru:2443';
```

Путь к приватному ключу, который используется для подписи "чека".
Приватный ключ необходимо указать в формате .pem. Для этого необходимо 
перевести сгенерированный в Nebula Generator приватный ключ в 
формате *.xml* (файл rsa_2048_public_key.xml) перевести *.pem* формат.
Для этого, например, можно воспользоваться 
этим [сервисом](https://superdry.apphb.com/tools/online-rsa-key-converter).
```
$sign_pkey = __DIR__ . '/keys/rsa_2048_public_key.pem'; //private key for signing
```

Путь к приватному ключу используемому для 2ssl взаимодействия. 
Здесь указывается файл `*ВАШ_ИНН*.key` из скачанного архива в личном кабинете:
```
$ssl_client_key = __DIR__ . '/keys/0000000000.key'; //path to client private key for ssl
```

Путь к клиентскому сертификату используемому для 2ssl.
Здесь указывается файл `*ВАШ_ИНН*.crt` из скачанного архива в личном кабинете:
```
$ssl_client_crt = __DIR__ . '/keys/client.crt'; //path to client certificate for ssl
```

Путь к cacert.pem:
```
$ssl_ca_cert = __DIR__ . '/keys/client_ca.crt'; // путь к файлу client_ca.crt (из скачанного архива в личном кабинете)
```

Пароль к клиентскому сертификату (если пароль отсутствует, то поставьте значение *null*):
```
$ssl_client_crt_pass = 'password'; //password for client certificate for ssl
```

Указываете ИНН:
```
$inn = '0123456789'; //ИНН
```

На основании исходных данных, создаем "клиента":
```
$buyer = new orangedata\orangedata_client(
        $inn, 
        $api_url,
        $sign_pkey,
        $ssl_client_key,
        $ssl_client_crt,
        $ssl_ca_cert,
        $ssl_client_crt_pass);
```     
Если хотим включить запись логов в файл 'curl.log', прописываем:
```
$buyer->is_debug();
```

Методы созданного "клиента" возвращают его самого, например:
```
$buyer->create_order(2, 1, 'a@b', 1); // создаст новый заказ внутри объекта (и вернет сам объект)
```

Добавить спички к заказу:
```
$buyer->add_position_to_order(6, 10, 1, 'matches', 1, 10);
```

Добавить оплату заказа:
```
$buyer
    ->add_payment_to_order(1, 10)
    ->add_payment_to_order(2, 50);   ///а можно и несколько разных оплат
```

Добавить агента:
```
$buyer->add_agent_to_order(127, ['+79998887766'], 'Operation', ['+79998887766'], ['+79998887766'], 'Name', 'ulitsa Adress, dom 7', 3123011520, ['+79998887766'])
```

Добавить дополнительный реквизит пользователя:
```
$buyer->add_user_attribute('Любимая цитата', 'В здоровом теле здоровый дух, этот лозунг еще не потух!');
```

и когда все готово - отправить заказ:
```
$order_result = $buyer->send_order();
```

Метод возвращает (bool) true в случае успешного завершения,
json с ошибками валидации, если таковые вернул сервер
либо бросит Exception, в прочих случаях.

Проверить его статус:
```
$order_status = $buyer->get_order_status(2); // 2 - ID заказа
```
Метод возвращает (bool) true в случае наличия "чека" в незавершенном статусе,
json с деталями заказа, в случае успешного завершения,
бросит Exception в прочих случаях.

Методы **send_order()** и **get_order_status($id)** возвращают ответ сервера,
в отличии от прочих методов, возвращающих сам родительский объект.

---
### Продакшн среда
Для использования в «боевом» режиме, необходимо использовать порт *12003*.